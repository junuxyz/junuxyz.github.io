<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Fluent Python Cheat Sheet for Newbies - jlog</title><meta name=description content="Personal blog and thoughts"><meta name=author content="Junu"><meta property="og:url" content="https://junuxyz.github.io/blog/posts/fluent-python-cheat-sheet-for-newbies/"><meta property="og:site_name" content="jlog"><meta property="og:title" content="Fluent Python Cheat Sheet for Newbies"><meta property="og:description" content="High-level ML frameworks and libraries (e.g., PyTorch, JAX, TensorFlow, NumPy, Triton, and many more) are mostly based on Python.
I’ve known Python for a while, but I’ve never learned it to a professional degree and wouldn’t say I’m good at Python programming. So, I decided to read Fluent Python (which seems to be one of the ‘bible’ figures of Python) to cover some topics and improve my Python programming skills."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-07-22T18:50:06+09:00"><meta property="article:modified_time" content="2025-07-22T18:50:06+09:00"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fluent Python Cheat Sheet for Newbies"><meta name=twitter:description content="High-level ML frameworks and libraries (e.g., PyTorch, JAX, TensorFlow, NumPy, Triton, and many more) are mostly based on Python.
I’ve known Python for a while, but I’ve never learned it to a professional degree and wouldn’t say I’m good at Python programming. So, I decided to read Fluent Python (which seems to be one of the ‘bible’ figures of Python) to cover some topics and improve my Python programming skills."><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel=stylesheet><link rel=stylesheet href=/css/variables.css><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/custom.css><link rel=icon type=image/x-icon href=/favicon.ico></head><body class=blog-section><header class=header><div class=header-content><div class=logo><a href=/blog/>jlog</a></div><button class=hamburger-menu aria-label="Toggle menu" aria-expanded=false>
<span></span>
<span></span>
<span></span></button><div class=header-right><nav class=nav><a href=/blog/categories/thoughts/ class=nav-item>Thoughts</a>
<a href=/blog/categories/ml/ class=nav-item>ML</a>
<a href=/ class=nav-item>About</a>
<a href=/blog/tags/ class=nav-item>Tags</a></nav></div></div></header><main class=main><div class=container><article class=post><header class=post-header><h1 class=post-title>Fluent Python Cheat Sheet for Newbies</h1><div class=post-meta><time datetime=2025-07-22T18:50:06+09:00>July 22, 2025</time><div class=post-tags><a href=/blog/tags/python/ class=tag>#python</a></div></div></header><div class=post-content><p>High-level ML frameworks and libraries (e.g., PyTorch, JAX, TensorFlow, NumPy, Triton, and many more) are mostly based on Python.</p><p>I&rsquo;ve known Python for a while, but I&rsquo;ve never learned it to a professional degree and wouldn&rsquo;t say I&rsquo;m good at Python programming. So, I decided to read <em>Fluent Python</em> (which seems to be one of the &lsquo;bible&rsquo; figures of Python) to cover some topics and improve my Python programming skills.</p><p>One thing that was hard for me while reading this book was that it was too dense to just understand and skip. I needed to type in the code, but even that wasn&rsquo;t enough. I figured this is a dictionary-like book that is hard to read repeatedly, so I decided to write a much more compact, digestable, and straightforward course note that works as a cheat sheet but also keeps the context as much as possible.</p><p><em>Note: This is not designed to be a replacement of the book, but for a handy review note or cheat sheet used daily.</em></p><p>Let&rsquo;s start.</p><h1 id=part-2-data-structures>Part 2. Data Structures</h1><h2 id=chapter-2-sequences>Chapter 2. Sequences</h2><p>A <em>sequence</em> in Python is a general term for an ordered collection of items. This means the items have a specific order, and you can access them by their position (their index).</p><p>We can divide sequences into types that can hold items of different type(<em>Container sequence</em>) or types that can&rsquo;t (<em>Flat sequence</em>). Flat sequences are more compact but are limited to holding primitive values.</p><p>Another way to divide is by mutability(<em>Mutable sequences</em> vs <em>Immutable sequences</em>).</p><h3 id=listcomps-and-genexps>Listcomps and Genexps</h3><p><strong>List Comprehension, or Listcomp</strong><br>this creates list with single line without using <code>for</code> loop or <code>.append()</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>arr</span> <span class=o>=</span> <span class=o>[</span>1,2,3<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>ex</span> <span class=o>=</span> <span class=o>[</span>-x <span class=k>for</span> x in arr<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; ex  
</span></span><span class=line><span class=cl><span class=o>[</span>-1, -2, -3<span class=o>]</span>
</span></span></code></pre></div><p>listcomp is even faster than <code>map</code> or <code>filter</code> at least in some cases.<br>(Try running <a href=https://github.com/fluentpython/example-code/blob/master/02-array-seq/listcomp_speed.py>this</a> in Python Shell if you are curious!)</p><p><strong>Cartesian Product</strong><br>this is just nested listcomp (double for loop).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>colors</span> <span class=o>=</span> <span class=o>[</span><span class=s1>&#39;black&#39;</span>, <span class=s1>&#39;white&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>sizes</span> <span class=o>=</span> <span class=o>[</span><span class=s1>&#39;S&#39;</span>, <span class=s1>&#39;M&#39;</span>, <span class=s1>&#39;L&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>tshirts</span> <span class=o>=</span> <span class=o>[(</span>color, size<span class=o>)</span> <span class=k>for</span> color in colors <span class=k>for</span> size in sizes<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; tshirts
</span></span><span class=line><span class=cl><span class=o>[(</span><span class=s1>&#39;black&#39;</span>, <span class=s1>&#39;S&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;black&#39;</span>, <span class=s1>&#39;M&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;black&#39;</span>, <span class=s1>&#39;L&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;white&#39;</span>, <span class=s1>&#39;S&#39;</span><span class=o>)</span>,
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s1>&#39;white&#39;</span>, <span class=s1>&#39;M&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;white&#39;</span>, <span class=s1>&#39;L&#39;</span><span class=o>)]</span>
</span></span></code></pre></div><p><strong>Generator Expression, or Genexps</strong></p><p>what this is/does: similar to listcomps but uses parantheses instead of square brackets. This <strong>saves memory</strong> because it <strong>yields</strong> items one by one using the iterator protocol instead of building a whole list and proceeding.</p><p>listcomp is expensive but reusable, generator is cheap but cannot be used again.</p><h3 id=tuples>Tuples</h3><p><strong>Tuples as Records</strong><br>Since tuples are immutable, they (to be more accurate, their location) can be used as records.</p><p><strong>Tuple Unpacking</strong><br>we can unpack tuples that have two or more values by assigning items from an iterable to a tuple of variables.</p><p>This is an example of tuple used as a record and unpacking it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>names</span> <span class=o>=</span> <span class=o>[(</span><span class=s1>&#39;junu&#39;</span>, <span class=s1>&#39;park&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;john&#39;</span>, <span class=s1>&#39;doe&#39;</span><span class=o>)]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=k>for</span> first_name, _ in names:  
</span></span><span class=line><span class=cl>... print<span class=o>(</span>first_name<span class=o>)</span>  
</span></span><span class=line><span class=cl>...  
</span></span><span class=line><span class=cl>junu  
</span></span><span class=line><span class=cl>john
</span></span></code></pre></div><p>we can use <code>*args</code> while unpacking tuple to extract the part(s) of what we want.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>names</span> <span class=o>=</span> <span class=o>[(</span><span class=s1>&#39;junu&#39;</span>, <span class=s1>&#39;park&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;john&#39;</span>, <span class=s1>&#39;doe&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;ruby&#39;</span>, <span class=s1>&#39;onRails&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;elon&#39;</span>, <span class=s1>&#39;musk&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;the&#39;</span>, <span class=s1>&#39;primagen&#39;</span><span class=o>)]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; a, b, *c <span class=o>=</span> names
</span></span><span class=line><span class=cl>&gt;&gt;&gt; a
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s1>&#39;junu&#39;</span>, <span class=s1>&#39;park&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; b
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s1>&#39;john&#39;</span>, <span class=s1>&#39;doe&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; c
</span></span><span class=line><span class=cl><span class=o>[(</span><span class=s1>&#39;ruby&#39;</span>, <span class=s1>&#39;onRails&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;elon&#39;</span>, <span class=s1>&#39;musk&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;the&#39;</span>, <span class=s1>&#39;primagen&#39;</span><span class=o>)]</span>
</span></span></code></pre></div><p>note that we can only use one args each time.</p><p><strong>Nested Tuple Unpacking</strong></p><p>If the expression of nested tuples match, Python will match the nesting structure and unpack it properly.</p><p>this is a non-realistic example but you will understand how nested tuple works by this example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>nested_tuple</span> <span class=o>=</span> <span class=o>[(</span><span class=s1>&#39;a&#39;</span>, <span class=o>(</span><span class=s1>&#39;b&#39;</span>, <span class=o>(</span><span class=s1>&#39;c&#39;</span>, <span class=o>(</span><span class=s1>&#39;d&#39;</span><span class=o>))))</span>, <span class=o>(</span><span class=s1>&#39;e&#39;</span>, <span class=o>(</span><span class=s1>&#39;f&#39;</span>, <span class=o>(</span><span class=s1>&#39;g&#39;</span>, <span class=o>(</span><span class=s1>&#39;h&#39;</span><span class=o>))))]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=k>for</span> <span class=o>(</span>x, <span class=o>(</span>y, <span class=o>(</span>z, <span class=o>(</span>w<span class=o>))))</span> in nested_tuple:
</span></span><span class=line><span class=cl>...     print<span class=o>(</span>x, y, z, w<span class=o>)</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>a b c d
</span></span><span class=line><span class=cl>e f g h
</span></span></code></pre></div><p><strong>Named Tuples</strong><br>This enhances the names(field names and a class name) of tuple.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; from collections import namedtuple
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>Name</span> <span class=o>=</span> namedtuple<span class=o>(</span><span class=s1>&#39;Name&#39;</span>, <span class=s1>&#39;first_name last_name&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>junu</span> <span class=o>=</span> Name<span class=o>(</span><span class=s1>&#39;Junu&#39;</span>, <span class=s1>&#39;Park&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>elon</span> <span class=o>=</span> Name<span class=o>(</span><span class=s1>&#39;Elon&#39;</span>, <span class=s1>&#39;Musk&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>prime</span> <span class=o>=</span> Name<span class=o>(</span><span class=s1>&#39;The&#39;</span>, <span class=s1>&#39;Primagen&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; junu
</span></span><span class=line><span class=cl>Name<span class=o>(</span><span class=nv>first_name</span><span class=o>=</span><span class=s1>&#39;Junu&#39;</span>, <span class=nv>last_name</span><span class=o>=</span><span class=s1>&#39;Park&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; elon
</span></span><span class=line><span class=cl>Name<span class=o>(</span><span class=nv>first_name</span><span class=o>=</span><span class=s1>&#39;Elon&#39;</span>, <span class=nv>last_name</span><span class=o>=</span><span class=s1>&#39;Musk&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; prime
</span></span><span class=line><span class=cl>Name<span class=o>(</span><span class=nv>first_name</span><span class=o>=</span><span class=s1>&#39;The&#39;</span>, <span class=nv>last_name</span><span class=o>=</span><span class=s1>&#39;Primagen&#39;</span><span class=o>)</span>
</span></span></code></pre></div><p>As you can see there are two parameters for namedtuple: first one is the class name and second are field names seperated by single space.</p><p>We can use additional methods supported in namedtuples such as,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Name<span class=o>(</span><span class=nv>first_name</span><span class=o>=</span><span class=s1>&#39;The&#39;</span>, <span class=nv>last_name</span><span class=o>=</span><span class=s1>&#39;Primagen&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; prime.last_name
</span></span><span class=line><span class=cl><span class=s1>&#39;Primagen&#39;</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; prime._asdict<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=o>{</span><span class=s1>&#39;first_name&#39;</span>: <span class=s1>&#39;The&#39;</span>, <span class=s1>&#39;last_name&#39;</span>: <span class=s1>&#39;Primagen&#39;</span><span class=o>}</span>
</span></span></code></pre></div><h3 id=slicing>Slicing</h3><p>You can slice not only lists but other sequence types like strings or tuples.</p><p><strong>Why slices and range exclude last item</strong><br>because it works well with the zero-based(starting from 0) indexing used in Python.</p><p>More specifically, it&rsquo;s</p><ul><li>easy to see the length of a slice or range when only the stop position is given.</li><li>easy to compute the length of a slice or range when start and stop are given by subtracting them.</li><li>easy to split a sequence in two parts at any index <code>x</code> using the same <code>x</code> without overlapping.</li></ul><p><strong>Using $+$ and $*$ with Sequences</strong></p><p>Multiplying list with integer copies of the same sequence works.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l</span> <span class=o>=</span> <span class=o>[</span>1,2,3<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l2</span> <span class=o>=</span> l * <span class=m>3</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l2  
</span></span><span class=line><span class=cl><span class=o>[</span>1, 2, 3, 1, 2, 3, 1, 2, 3<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l<span class=o>)</span>  
</span></span><span class=line><span class=cl><span class=m>139738068947456</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l2<span class=o>)</span>  
</span></span><span class=line><span class=cl><span class=m>139738067406976</span>
</span></span></code></pre></div><p><strong>Building Lists of Lists</strong></p><p>The problem appears when the elements in the list are mutable items. The most common case is building lists of lists.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>board1</span> <span class=o>=</span> <span class=o>[[</span><span class=s1>&#39;_&#39;</span><span class=o>]</span> * <span class=m>3</span> <span class=k>for</span> i in range<span class=o>(</span>3<span class=o>)]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board1  
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board1<span class=o>[</span>1<span class=o>][</span>2<span class=o>]</span> <span class=o>=</span> <span class=s1>&#39;x&#39;</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board1  
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;x&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board1<span class=o>[</span>0<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738042877824</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board1<span class=o>[</span>1<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738043505344</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board1<span class=o>[</span>2<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738043329344</span>
</span></span></code></pre></div><p>board1 works fine, meaning it has different address for each sub arrays.</p><p>but if we multiply list, it just references the same list:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>board2</span> <span class=o>=</span> <span class=o>[[</span><span class=s1>&#39;_&#39;</span><span class=o>]</span> * 3<span class=o>]</span> * <span class=m>3</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board2
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board<span class=o>[</span>1<span class=o>][</span>2<span class=o>]</span> <span class=o>=</span> <span class=s1>&#39;x&#39;</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board2
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board2<span class=o>[</span>1<span class=o>][</span>2<span class=o>]</span> <span class=o>=</span> <span class=s1>&#39;x&#39;</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board2
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;x&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;x&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;x&#39;</span><span class=o>]]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board2<span class=o>[</span>0<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738065760064</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board2<span class=o>[</span>1<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738065760064</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board2<span class=o>[</span>2<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738065760064</span>
</span></span></code></pre></div><p>which means it just appends the same row three times.</p><p><strong>Augmented Assignments</strong> (<code>+=</code> and <code>*=</code>)</p><p>augmented assignments are NOT the same as adding or multiplying.<br>While <code>+</code> internaly uses special function <code>__add__()</code>, <code>+=</code> uses special function <code>__iadd__()</code>.<br><strong>Only if <code>__iadd__()</code> is not implemented in the class, it works the same as <code>__add__()</code>.</strong></p><p>so, when does it change?<br>In mutable sequences (such as lists), <code>__iadd__()</code> will be changed <strong>in place</strong> (using less memory) but in other cases, it will work as <code>__add__()</code> which means <code>a = a + b</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l</span> <span class=o>=</span> <span class=o>[</span>1,2,3<span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738065799168</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>mul_list</span> <span class=o>=</span> l * <span class=m>3</span> <span class=c1># __mul__()</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>mul_list<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738068947456</span> <span class=c1># different address</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l *<span class=o>=</span> <span class=m>3</span> <span class=c1># __imul__()</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738065799168</span> <span class=c1># changed in place</span>
</span></span></code></pre></div><p><strong>A+= Assignment Puzzler</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>t</span> <span class=o>=</span> <span class=o>(</span>1, 2, <span class=o>[</span>30, 40<span class=o>])</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; t<span class=o>[</span>2<span class=o>]</span> +<span class=o>=</span> <span class=o>[</span>50, 60<span class=o>]</span>
</span></span></code></pre></div><p>This is a corner case that I won&rsquo;t go into details since it seems too peripheral.<br>To explain breifly, this will both make an error but also augment the list into <code>[30, 40, 50, 60]</code>.</p><blockquote><p>• Putting mutable items in tuples is not a good idea.<br>• <strong>Augmented assignment is not an atomic operation</strong>—we just saw it throwing an exception after doing part of its job.<br>• Inspecting Python bytecode is not too difficult, and is often helpful to see what is going on under the hood.</p></blockquote><h3 id=sorting>Sorting</h3><p>There are mainly two built-in sorting functions, which is <code>list.sort</code> and <code>sorted</code>.</p><p><code>list.sort</code> does create a copy, but sort the list in place. It returns <code>None</code> to remind it.</p><p>Note: This is a nice pattern to know about Python API conventions: Python usually outputs <code>None</code> to make it clear the function doesn&rsquo;t create a copy but changes the object in place.</p><p><code>sorted</code> creates a new list and returns it. Therefore, takes additional memory. This also means it can take any kinds of iterable object including immutable ones, such as tuples. Note that it always outputs a new <strong>list</strong>.</p><p>Both of the functions take two arguments which are <code>reversed: bool</code> and <code>key: string</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l</span> <span class=o>=</span> <span class=o>[</span><span class=s1>&#39;a&#39;</span>, <span class=s1>&#39;b&#39;</span>, <span class=s1>&#39;c&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>sorted_l</span> <span class=o>=</span> sorted<span class=o>(</span>l<span class=o>)</span> <span class=c1># example of `sorted`</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738067138496</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; sorted_l
</span></span><span class=line><span class=cl><span class=o>[</span><span class=s1>&#39;a&#39;</span>, <span class=s1>&#39;b&#39;</span>, <span class=s1>&#39;c&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>sorted_l<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738065799168</span> <span class=c1># another array created</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l.sort<span class=o>()</span> <span class=c1># example of `list.sort`</span>
</span></span></code></pre></div><p>Sorting is very helpful because once the sequence is sorted, each elements can be very efficiently searched.</p><h3 id=managing-ordered-sequence-with-bisect>Managing Ordered Sequence with <code>bisect</code></h3><p>It is good to keep the sorted sequence since sorting is <strong>expensive</strong>.<br><code>bisect.bisect</code> and <code>bisect.insort</code> helps a much efficient way to search and insert than <code>list</code> functions.</p><p><a href=https://en.wikipedia.org/wiki/Binary_search>Binary Search Algorithm</a> is provided via <code>bisect</code> module in Python standard library.</p><p>Bisect is an efficient way to search and insert elements into a sequence <strong>while keeping the order</strong> in an ordered sequence.</p><p><code>bisect()</code> returns the location where the element should be inserted in order to maintain the order while <code>insort()</code> finds the location and inserts the element.</p><p>a quick minimal example would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; import bisect
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l</span> <span class=o>=</span> <span class=o>[</span>1, 2, 3, 4, 5<span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l
</span></span><span class=line><span class=cl><span class=o>[</span>1, 2, 3, 4, 5<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># bisect only tells you the location</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.bisect<span class=o>(</span>l, 6<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>5</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.bisect<span class=o>(</span>l, 3<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>3</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.bisect<span class=o>(</span>l, 4<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>4</span>
</span></span><span class=line><span class=cl><span class=c1># insort actually inserts the array</span>
</span></span><span class=line><span class=cl><span class=c1># this is an in-place exchange so only one block of</span>
</span></span><span class=line><span class=cl><span class=c1># memory will be added</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.insort<span class=o>(</span>l, 3<span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l
</span></span><span class=line><span class=cl><span class=o>[</span>1, 2, 3, 3, 4, 5<span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.bisect<span class=o>(</span>l, 3<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>4</span>
</span></span></code></pre></div><h3 id=when-a-list-is-not-the-answer>When a List is Not the Answer</h3><p><strong>Arrays</strong></p><p>When creating an array,</p><ol><li>you provide a typecode</li><li>a letter to determine the underlying C type used to store each item in the array.</li></ol><p>For example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; from array import array
</span></span><span class=line><span class=cl>&gt;&gt;&gt; from random import random
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>floats</span> <span class=o>=</span> array <span class=o>(</span><span class=s1>&#39;d&#39;</span>, <span class=o>(</span>random<span class=o>()</span> <span class=k>for</span> i in range<span class=o>(</span>2**10<span class=o>)))</span>
</span></span></code></pre></div><p>&lsquo;b&rsquo;: signed char<br>&rsquo;d&rsquo;: double</p><p>whatever you assign to, the array will interpret as the type you assigned to it.</p><p>Fast loading and saving are available via <code>.frombytes</code> and <code>.tofile</code><br>Binary file can be 60x faster than reading numbers in text file.</p><p><strong>Memory Views</strong></p><blockquote><p>A memoryview is essentially a generalized NumPy array structure in Python itself (without the math). It allows you to share memory between data-structures (things like PIL images, SQLlite databases, NumPy arrays, etc.) without first copying.</p></blockquote><p><strong>NumPy and SciPy</strong></p><p><strong>Deque</strong></p><p><code>deque</code> (not <em>dequeue</em>) stands for &lsquo;double-ended queue&rsquo;.</p><p>Removing items from the middle of a <code>deque</code> is not as fast. It&rsquo;s optimized for appending and popping from the end. Used in LIFO queue.</p><p>deque internally is implemented as a doubly linked list of fixed-size blocks. Therefore traversing to the middle would be more ineffecient than accesing the ends.</p><br>## Chapter 3. dicts and sets<blockquote><p>Hash tables are the engines behind Python&rsquo;s high-performance dicts.</p></blockquote><p>All mapping types in the std library use the basic dict in their implementation, which means all keys(while values are not required) must be <em>hashable</em>.</p><p>This means, in order to understand how dictionary or set in Python works under the hood, we should understand about hash first.</p><p><strong>About <em>hash</em></strong></p><p><em>What is hash and what does it mean to be hashable?</em></p><blockquote><p>The hash() built-in function works directly with built-in types and falls back to calling <strong>hash</strong> for user-defined types. If two objects compare equal, their hash values must also be equal, otherwise the hash table algorithm does not work.</p></blockquote><p>A <em>hash</em> is a numeric value that Python calculates for a hashable object.<br>It&rsquo;s like a unique, short fingerprint for that specific object.<br><em>hashable</em> means it can be hashed.</p><p><em>Why does hash make searching faster?</em></p><p>When we feed in a hashable key-value pair, Python will take the (hashable) key and feed it to a <em>hash function</em>. This function will quickly compute an integer number called <em>hash value</em>.</p><p>This hash value is then mathematically mapped to a specific index (or bucket) within an internal array that the dictionary uses to store its items.</p><p>This makes <strong>direct memory access available</strong>. This means, hash table design allows Python to use key to <strong>go directly</strong> to the calculated index in its internal value, without needing to scan other parts of the memory.</p><p><em>What are the hashable types?</em></p><ul><li>atomic immutable types (such as <code>str</code>)</li><li><code>frozen set</code></li><li><code>tuple</code> is hashable only if all its items are hashable<ul><li>If we look at the example below, unlike <code>tf</code>, <code>tl</code> will produce an error since there is an unhashable list inside the tuples.</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>tl</span> <span class=o>=</span> <span class=o>(</span>1,2,<span class=o>[</span>30,40<span class=o>])</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; hash<span class=o>(</span>tl<span class=o>)</span>
</span></span><span class=line><span class=cl>Traceback <span class=o>(</span>most recent call last<span class=o>)</span>: 
</span></span><span class=line><span class=cl>File <span class=s2>&#34;&lt;stdin&gt;&#34;</span>, line 1, in &lt;module&gt;
</span></span><span class=line><span class=cl>TypeError: unhashable type: <span class=s1>&#39;list&#39;</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt;
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>tf</span> <span class=o>=</span> <span class=o>(</span>1,2,frozenset<span class=o>([</span>30,40<span class=o>]))</span> 
</span></span><span class=line><span class=cl>&gt;&gt;&gt; hash<span class=o>(</span>tf<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>5149391500123939311</span>
</span></span></code></pre></div><p><em>What is a hash table?</em></p><p>Hash table is a sparse array. Cells in hash table are often called <em>buckets</em><br>Python tries to keep at least 1/3 of the buckets empty; if the hash table becomes too crowded, it is copied to a new location with room for more buckets (dynamic memory allocation)</p><p>When different hash values result in the same bucket, it is called <em>hash collision</em>. There are several ways to deal with hash collision. Python uses <em>open addressing</em> which uses a complex internal algorithm to assign the next bucket. The main goal is to reduce hash collision as much as possible.</p><p><strong>set vs frozenset</strong><br>The difference is <strong>mutability</strong>.<br>frozenset is an immutable version of set. You can’t add, remove, or change its elements.</p><p><strong>Variations of dicts</strong></p><p>There are multiple ways to create dicts.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>a</span> <span class=o>=</span> dict<span class=o>(</span><span class=nv>one</span><span class=o>=</span>1, <span class=nv>two</span><span class=o>=</span>2, <span class=nv>three</span><span class=o>=</span>3<span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>b</span> <span class=o>=</span> <span class=o>{</span><span class=s1>&#39;one&#39;</span>: 1, <span class=s1>&#39;two&#39;</span>: 2, <span class=s1>&#39;three&#39;</span>: 3<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1># combine multiple iterable objects element-wise</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>c</span> <span class=o>=</span> dict<span class=o>(</span>zip<span class=o>([</span><span class=s1>&#39;one&#39;</span>, <span class=s1>&#39;two&#39;</span>, <span class=s1>&#39;three&#39;</span><span class=o>]</span>, <span class=o>[</span>1,2,3<span class=o>]))</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>d</span> <span class=o>=</span> dict<span class=o>([(</span><span class=s1>&#39;two&#39;</span>,2<span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;one&#39;</span>, 1<span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;three&#39;</span>, 3<span class=o>)])</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>e</span> <span class=o>=</span> dict<span class=o>({</span><span class=s1>&#39;three&#39;</span>: 3, <span class=s1>&#39;one&#39;</span>: 1, <span class=s1>&#39;two&#39;</span>: 2<span class=o>})</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>a</span> <span class=o>==</span> <span class=nv>b</span> <span class=o>==</span> <span class=nv>c</span> <span class=o>==</span> <span class=nv>d</span> <span class=o>==</span> e  
</span></span><span class=line><span class=cl>True
</span></span></code></pre></div><p><strong>Handling Missing Keys with <code>setdefault</code></strong></p><p>When looking up table and checking if it&rsquo;s key is missing, it&rsquo;s more efficient to use <code>setdefault</code> than <code>d.get(k, default)</code>.</p><h3 id=mappings-with-flexible-key-lookup>Mappings with Flexible Key Lookup</h3><p>This is used to return some made up value when missing key is searched.</p><p>We can do this either by 1. <code>default dict</code> instead of <code>dict</code> or 2. any other mapping type + <code>__missing__</code> method.</p><p><strong>defaultdict</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>index</span> <span class=o>=</span> <span class=n>collections</span><span class=o>.</span><span class=n>defaultdict</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
</span></span></code></pre></div><p>if default factory is not provided, <code>KeyError</code> will be raised for missing keys.</p><h3 id=variations-of-dict>Variations of dict</h3><p><code>collections.OrderedDict</code><br>Maintains keys in insertion order<br>FIFO when it&rsquo;s default, but LIFO if <code>my_odict.popitem(last=True)</code></p><p><code>collections.ChainMap</code></p><h3 id=dict-and-set-under-the-hood>dict and set under the hood</h3><p><strong>list vs set/dict</strong><br>because there is no hash table to support searches with the in operator on a list, so a full scan must be made, resulting in times that grow linearly with the size of the haystack.</p><p><strong>dicts have significant memory overhead</strong></p><p>When you use dictionaries, Python has to do extra work behind the scenes to make them fast for looking things up. This extra work involves creating a &ldquo;hash table,&rdquo; which is like a special, spacious grid for organizing data.</p><p>hash tables must be sparse to work, which means it’s NOT space efficient</p><p>If you have many dictionaries, you are using memory-intensive hash tables. Tuples might be a better choice to avoid significant memory overhead.</p><p><strong>Key Search is very fast</strong></p><p>dict is trading space for time. They provide fast access regardless of the size of the dict.</p><p>When <strong>hash collisions</strong> occur, whether <code>a</code> bumps <code>b</code> to a different memory location (A-B case) or <code>b</code> bumps <code>a</code> (B-A case), the key point is while Python has enough <strong>memory space</strong> to handle these adjustments, they are considered the same.</p><p>Python&rsquo;s <code>==</code>(equality) check for dictionaries focuses solely on whether the <strong>same key-value pairs</strong> exist in both dictionaries. It doesn&rsquo;t care about the internal <strong>order of keys</strong> or the <strong>specific memory addresses</strong> where they&rsquo;re stored. As long as <code>key_A</code> maps to <code>value_A</code> and <code>key_B</code> maps to <code>value_B</code> in both dictionaries, they are considered equal, regardless of the behind-the-scenes memory acrobatics.</p><p><strong>Adding items to a dict may change the order of existing keys</strong></p><p>Dynamic memory allocation may happen as more items are added to the hash table (in order to keep it sparse). During this process, new but different hash collisions may happen while copying the existing keys which changes the order of them.</p><p>This is why modifying the contents of a <code>dict</code> <strong>while</strong> iterating is generally a bad idea.<br>If you need to scan and add items to a dictionary, first read all of the elements (without modification) and collect the needed additions in a second <code>dict</code>. Then update the original dict by appending the new one.</p><h3 id=how-sets-work>How Sets work</h3><p>set is similar to dict but the only difference is that each bucket holds only a reference to the element, while dict holds both key and value.</p><p>Basically, set is a dictionary but does not have value attached.<br>Only keys.</p><br>## Chapter 4. Text vs Bytes<p>As mentioned in page 97 (&ldquo;In the end, most of the issues covered in this chapter do not affect programmers who deal only with ASCII text.&rdquo;), I will skip most of the parts in this chapter since these does not seem to be my immediate interest for now.</p><h3 id=byte-essentials>Byte Essentials</h3><p>two types of binary sequences:</p><ul><li>mutable <code>bytearray</code></li><li>immutable <code>bytes</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>cafe</span> <span class=o>=</span> bytes<span class=o>(</span><span class=s1>&#39;café&#39;</span>, <span class=nv>encoding</span><span class=o>=</span><span class=s1>&#39;utf-8&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; cafe
</span></span><span class=line><span class=cl>b<span class=s1>&#39;caf\xc3\xa9&#39;</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; cafe<span class=o>[</span>0<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=m>99</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; cafe<span class=o>[</span>:1<span class=o>]</span>
</span></span><span class=line><span class=cl>b<span class=s1>&#39;c&#39;</span>
</span></span></code></pre></div><p>bytes can be built from a <code>str</code>, given an encoding.<br>All the elements in utf-8 encoded bytes are <code>int</code>s of range(256) (0~256).<br>Check the Note below why <code>cafe[0]</code> is <code>int</code> but <code>cafe[:1]</code> isn&rsquo;t.</p><p><em>Note: The fact that <code>cafe[0]</code> retrieves an int but <code>cafe[:1]</code> returns a bytes object of length 1 should not be surprising. The only sequence type where <code>s[0] == s[:1]</code> is the str type. Al though practical, this behavior of <code>str</code> is exceptional. For every other sequence, <code>s[i]</code> returns one item, and <code>s[i:i+1]</code> returns a sequence of the same type with the <code>s[1]</code> item inside it</em></p><h3 id=handling-text-files>Handling Text Files</h3><p>The best pracitce of handling text file is to follow the <strong>&ldquo;Unicode sandwitch&rdquo;</strong> principle. It means that <code>bytes</code> should be decoded to <code>str</code> as early as possible on input, processed as <code>str</code>, and encoded to <code>bytes</code> as late as possible.</p><h1 id=part-3-functions-as-objects>Part 3. Functions as Objects</h1><h2 id=chapter-5-first-class-function>Chapter 5. First-Class Function</h2><blockquote><p>Functions in Python are first-class objects.</p><p>Programming language theorists define a “first-class object” as a program entity that can be:<br>• Created at runtime<br>• Assigned to a variable or element in a data structure<br>• Passed as an argument to a function<br>• Returned as the result of a function</p></blockquote><h3 id=treating-function-like-an-object>Treating Function Like an Object</h3><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt;&gt;&gt; def factorial<span class=o>(</span>n<span class=o>)</span>:
</span></span><span class=line><span class=cl>...     <span class=s1>&#39;&#39;&#39;returns n&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl>...     <span class=k>return</span> <span class=m>1</span> <span class=k>if</span> n &lt; <span class=m>2</span> <span class=k>else</span> n * factorial<span class=o>(</span>n-1<span class=o>)</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>&gt;&gt;&gt; factorial<span class=o>(</span>42<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>1405006117752879898543142606244511569936384000000000</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; factorial
</span></span><span class=line><span class=cl>&lt;<span class=k>function</span> factorial at 0x7f66ffe57880&gt;
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>fact</span> <span class=o>=</span> factorial
</span></span><span class=line><span class=cl>&gt;&gt;&gt; fact
</span></span><span class=line><span class=cl>&lt;<span class=k>function</span> factorial at 0x7f66ffe57880&gt;
</span></span><span class=line><span class=cl>&gt;&gt;&gt; fact<span class=o>(</span>42<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>1405006117752879898543142606244511569936384000000000</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; list<span class=o>(</span>map<span class=o>(</span>fact, range<span class=o>(</span>11<span class=o>)))</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800<span class=o>]</span>
</span></span></code></pre></div><h3 id=higher-order-functions>Higher-Order Functions</h3><p>Higher-Order Function is function that takes a function as argument or returns function as the result. (ex. <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>sorted</code> &mldr;)</p><p>For example, we can take functions as elements for the <code>key=</code> parameter in <code>sorted</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>fruits</span> <span class=o>=</span> <span class=o>[</span><span class=s1>&#39;strawberry&#39;</span>, <span class=s1>&#39;fig&#39;</span>, <span class=s1>&#39;apple&#39;</span>, <span class=s1>&#39;cherry&#39;</span>, <span class=s1>&#39;rasberry&#39;</span>, <span class=s1>&#39;banana&#39;</span><span class=o>]</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># using len</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; sorted<span class=o>(</span>fruits, <span class=nv>key</span><span class=o>=</span>len<span class=o>)</span>  
</span></span><span class=line><span class=cl><span class=o>[</span><span class=s1>&#39;fig&#39;</span>, <span class=s1>&#39;apple&#39;</span>, <span class=s1>&#39;cherry&#39;</span>, <span class=s1>&#39;banana&#39;</span>, <span class=s1>&#39;rasberry&#39;</span>, <span class=s1>&#39;strawberry&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># using custom function(reverse)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; def reverse<span class=o>(</span>word<span class=o>)</span>:  
</span></span><span class=line><span class=cl>... <span class=k>return</span> word<span class=o>[</span>::-1<span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; sorted<span class=o>(</span>fruits, <span class=nv>key</span><span class=o>=</span>reverse<span class=o>)</span>  
</span></span><span class=line><span class=cl><span class=o>[</span><span class=s1>&#39;banana&#39;</span>, <span class=s1>&#39;apple&#39;</span>, <span class=s1>&#39;fig&#39;</span>, <span class=s1>&#39;rasberry&#39;</span>, <span class=s1>&#39;strawberry&#39;</span>, <span class=s1>&#39;cherry&#39;</span><span class=o>]</span>  
</span></span></code></pre></div><p>Note that key is only used to determine the sorting order, but does NOT change the content.</p><h3 id=modern-replacements-for-map-filter-and-reduce>Modern Replacements for map, filter, and reduce</h3><p>We can use listcomp and genexp instead of map.<br>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># map and  listcomp</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>a1</span> <span class=o>=</span> list<span class=o>(</span>map<span class=o>(</span>factorial, range<span class=o>(</span>6<span class=o>)))</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>a2</span> <span class=o>=</span> <span class=o>[</span>factorial<span class=o>(</span>x<span class=o>)</span> <span class=k>for</span> x in range<span class=o>(</span>6<span class=o>)]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; a1  
</span></span><span class=line><span class=cl><span class=o>[</span>1, 1, 2, 6, 24, 120<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; a2  
</span></span><span class=line><span class=cl><span class=o>[</span>1, 1, 2, 6, 24, 120<span class=o>]</span>  
</span></span></code></pre></div><p><strong>map vs generator</strong></p><p><code>map</code> and <code>generator</code> are two different types of iterators.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>a3</span> <span class=o>=</span> map<span class=o>(</span>factorial, range<span class=o>(</span>6<span class=o>))</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>a4</span> <span class=o>=</span> <span class=o>(</span>factorial<span class=o>(</span>x<span class=o>)</span> <span class=k>for</span> x in range<span class=o>(</span>6<span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; type<span class=o>(</span>a3<span class=o>)</span>  
</span></span><span class=line><span class=cl>&lt;class <span class=s1>&#39;map&#39;</span>&gt;  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; type<span class=o>(</span>a4<span class=o>)</span>  
</span></span><span class=line><span class=cl>&lt;class <span class=s1>&#39;generator&#39;</span>&gt;
</span></span></code></pre></div></div><nav class=post-nav><div class=nav-prev><a href=/blog/posts/lab01-adding-vector/ class=nav-link><span class=nav-label>previous: </span><span class=nav-title>Lab01: Adding Vector</span></a></div><div class=nav-next><a href=/blog/posts/at-its-core-ai-is-about-finding-patterns/ class=nav-link><span class=nav-label>next: </span><span class=nav-title>At its core, AI is about finding patterns</span></a></div></nav></article></div></main><footer class=footer><div class=footer-content><p>&copy; 2025 jlog. Built with <a href=https://gohugo.io/>Hugo</a>.</p><div class=social-icons><a href=https://github.com/junuxyz class=social-icon aria-label=GitHub target=_blank rel=noopener>GitHub
</a><a href=mailto:jpjunior211@gmail.com class=social-icon aria-label=Email target=_blank rel=noopener>Email</a></div></div></footer><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelector(".hamburger-menu"),e=document.querySelector(".header-right");if(t&&e){t.addEventListener("click",function(){const t=this.getAttribute("aria-expanded")==="true";this.setAttribute("aria-expanded",!t),e.classList.toggle("active")});const n=e.querySelectorAll(".nav-item");n.forEach(n=>{n.addEventListener("click",function(){t.setAttribute("aria-expanded","false"),e.classList.remove("active")})}),document.addEventListener("click",function(n){!e.contains(n.target)&&!t.contains(n.target)&&(t.setAttribute("aria-expanded","false"),e.classList.remove("active"))})}document.querySelectorAll("pre code").forEach(e=>{const t=e.parentElement;if(!t.querySelector(".code-copy-btn")){const n=document.createElement("button");n.className="code-copy-btn",n.setAttribute("aria-label","Copy code to clipboard");const s=`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="5" y="5" width="8" height="8" rx="1" stroke="currentColor" stroke-width="1.5" fill="none"/>
                        <path d="M4 3C4 2.44772 4.44772 2 5 2H9C9.55228 2 10 2.44772 10 3V4H5C4.44772 4 4 4.44772 4 5V11C4 11.5523 4.44772 12 5 12H6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>`,o=`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M13.5 4.5L6 12L2.5 8.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>`;n.innerHTML=s,n.addEventListener("click",()=>{navigator.clipboard.writeText(e.textContent).then(()=>{n.innerHTML=o,n.classList.add("copied"),setTimeout(()=>{n.innerHTML=s,n.classList.remove("copied")},2e3)})}),t.style.position="relative",t.appendChild(n)}if(!t.querySelector(".code-language")){let n=e.getAttribute("data-lang");if(!n){const t=(e.className||"").match(/language-([^\s]+)/);t&&t[1]&&(n=t[1])}if(n){const e=document.createElement("span");e.className="code-language",e.textContent=n.charAt(0).toUpperCase()+n.slice(1),t.appendChild(e)}}})})</script></body></html>