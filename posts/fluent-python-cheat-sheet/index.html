<!doctype html><html lang=en-us class=theme-auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Fluent Python Cheat Sheet for Newbies - junuxyz</title><meta name=description content="Personal blog and thoughts"><meta name=author content="Junu"><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/syntax.css><link rel=icon type=image/x-icon href=/favicon.ico><script>const theme=localStorage.getItem("theme")||"auto";(theme==="dark"||theme==="auto"&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.documentElement.classList.add("dark")</script></head><body><header class=header><div class=header-content><div class=logo><a href=https://junuxyz.github.io/>junuxyz</a></div><div class=header-right><nav class=nav><a href=/categories/thoughts/ class=nav-item>Thoughts</a>
<a href=/categories/ml/ class=nav-item>ML</a>
<a href=/about/ class=nav-item>About</a>
<a href=/tags/ class=nav-item>Tags</a></nav><button id=theme-toggle type=button aria-label="Toggle theme">
<svg class="sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
<svg class="moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></button></div></div></header><main class=main><div class=container><article class=post><header class=post-header><h1 class=post-title>Fluent Python Cheat Sheet for Newbies</h1><div class=post-meta><time datetime=2025-07-22T18:50:06+09:00>July 22, 2025</time><div class=post-tags><a href=/tags/python/ class=tag>#python</a></div></div></header><div class=post-content><p>High-level ML frameworks and libraries (e.g., PyTorch, JAX, TensorFlow, NumPy, Triton, and many more) are mostly based on Python.</p><p>I&rsquo;ve known Python for a while, but I&rsquo;ve never learned it to a professional degree and wouldn&rsquo;t say I&rsquo;m good at Python programming. So, I decided to read <em>Fluent Python</em> (which seems to be one of the &lsquo;bible&rsquo; figures of Python) to cover some topics and improve my Python programming skills.</p><p>One thing that was hard for me while reading this book was that it was too dense to just understand and skip. I needed to type in the code, but even that wasn&rsquo;t enough. I figured this is a dictionary-like book that is hard to read repeatedly, so I decided to write a much more compact, digestable, and straightforward course note that works as a cheat sheet but also keeps the context as much as possible.</p><p><em>Note: This is not designed to be a replacement of the book, but for a handy review note or cheat sheet used daily.</em></p><p>Let&rsquo;s start.</p><h1 id=part-2-data-structures>Part 2. Data Structures</h1><h2 id=chapter-2-sequences>Chapter 2. Sequences</h2><p>A <em>sequence</em> in Python is a general term for an ordered collection of items. This means the items have a specific order, and you can access them by their position (their index).</p><p>We can divide sequences into types that can hold items of different type(<em>Container sequence</em>) or types that can&rsquo;t (<em>Flat sequence</em>). Flat sequences are more compact but are limited to holding primitive values.</p><p>Another way to divide is by mutability(<em>Mutable sequences</em> vs <em>Immutable sequences</em>).</p><h3 id=listcomps-and-genexps>Listcomps and Genexps</h3><p><strong>List Comprehension, or Listcomp</strong>
this creates list with single line without using <code>for</code> loop or <code>.append()</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>arr</span> <span class=o>=</span> <span class=o>[</span>1,2,3<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>ex</span> <span class=o>=</span> <span class=o>[</span>-x <span class=k>for</span> x in arr<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; ex  
</span></span><span class=line><span class=cl><span class=o>[</span>-1, -2, -3<span class=o>]</span>
</span></span></code></pre></div><p>listcomp is even faster than <code>map</code> or <code>filter</code> at least in some cases.
(Try running <a href=https://github.com/fluentpython/example-code/blob/master/02-array-seq/listcomp_speed.py>this</a> in Python Shell if you are curious!)</p><p><strong>Cartesian Product</strong>
this is just nested listcomp (double for loop).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>colors</span> <span class=o>=</span> <span class=o>[</span><span class=s1>&#39;black&#39;</span>, <span class=s1>&#39;white&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>sizes</span> <span class=o>=</span> <span class=o>[</span><span class=s1>&#39;S&#39;</span>, <span class=s1>&#39;M&#39;</span>, <span class=s1>&#39;L&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>tshirts</span> <span class=o>=</span> <span class=o>[(</span>color, size<span class=o>)</span> <span class=k>for</span> color in colors <span class=k>for</span> size in sizes<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; tshirts
</span></span><span class=line><span class=cl><span class=o>[(</span><span class=s1>&#39;black&#39;</span>, <span class=s1>&#39;S&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;black&#39;</span>, <span class=s1>&#39;M&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;black&#39;</span>, <span class=s1>&#39;L&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;white&#39;</span>, <span class=s1>&#39;S&#39;</span><span class=o>)</span>,
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s1>&#39;white&#39;</span>, <span class=s1>&#39;M&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;white&#39;</span>, <span class=s1>&#39;L&#39;</span><span class=o>)]</span>
</span></span></code></pre></div><p><strong>Generator Expression, or Genexps</strong></p><p>what this is/does: similar to listcomps but uses parantheses instead of square brackets. This <strong>saves memory</strong> because it <strong>yields</strong> items one by one using the iterator protocol instead of building a whole list and proceeding.</p><p>listcomp is expensive but reusable, generator is cheap but cannot be used again.</p><h3 id=tuples>Tuples</h3><p><strong>Tuples as Records</strong>
Since tuples are immutable, they (to be more accurate, their location) can be used as records.</p><p><strong>Tuple Unpacking</strong>
we can unpack tuples that have two or more values by assigning items from an iterable to a tuple of variables.</p><p>This is an example of tuple used as a record and unpacking it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>names</span> <span class=o>=</span> <span class=o>[(</span><span class=s1>&#39;junu&#39;</span>, <span class=s1>&#39;park&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;john&#39;</span>, <span class=s1>&#39;doe&#39;</span><span class=o>)]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=k>for</span> first_name, _ in names:  
</span></span><span class=line><span class=cl>... print<span class=o>(</span>first_name<span class=o>)</span>  
</span></span><span class=line><span class=cl>...  
</span></span><span class=line><span class=cl>junu  
</span></span><span class=line><span class=cl>john
</span></span></code></pre></div><p>we can use <code>*args</code> while unpacking tuple to extract the part(s) of what we want.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>names</span> <span class=o>=</span> <span class=o>[(</span><span class=s1>&#39;junu&#39;</span>, <span class=s1>&#39;park&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;john&#39;</span>, <span class=s1>&#39;doe&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;ruby&#39;</span>, <span class=s1>&#39;onRails&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;elon&#39;</span>, <span class=s1>&#39;musk&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;the&#39;</span>, <span class=s1>&#39;primagen&#39;</span><span class=o>)]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; a, b, *c <span class=o>=</span> names
</span></span><span class=line><span class=cl>&gt;&gt;&gt; a
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s1>&#39;junu&#39;</span>, <span class=s1>&#39;park&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; b
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s1>&#39;john&#39;</span>, <span class=s1>&#39;doe&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; c
</span></span><span class=line><span class=cl><span class=o>[(</span><span class=s1>&#39;ruby&#39;</span>, <span class=s1>&#39;onRails&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;elon&#39;</span>, <span class=s1>&#39;musk&#39;</span><span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;the&#39;</span>, <span class=s1>&#39;primagen&#39;</span><span class=o>)]</span>
</span></span></code></pre></div><p>note that we can only use one args each time.</p><p><strong>Nested Tuple Unpacking</strong></p><p>If the expression of nested tuples match, Python will match the nesting structure and unpack it properly.</p><p>this is a non-realistic example but you will understand how nested tuple works by this example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>nested_tuple</span> <span class=o>=</span> <span class=o>[(</span><span class=s1>&#39;a&#39;</span>, <span class=o>(</span><span class=s1>&#39;b&#39;</span>, <span class=o>(</span><span class=s1>&#39;c&#39;</span>, <span class=o>(</span><span class=s1>&#39;d&#39;</span><span class=o>))))</span>, <span class=o>(</span><span class=s1>&#39;e&#39;</span>, <span class=o>(</span><span class=s1>&#39;f&#39;</span>, <span class=o>(</span><span class=s1>&#39;g&#39;</span>, <span class=o>(</span><span class=s1>&#39;h&#39;</span><span class=o>))))]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=k>for</span> <span class=o>(</span>x, <span class=o>(</span>y, <span class=o>(</span>z, <span class=o>(</span>w<span class=o>))))</span> in nested_tuple:
</span></span><span class=line><span class=cl>...     print<span class=o>(</span>x, y, z, w<span class=o>)</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>a b c d
</span></span><span class=line><span class=cl>e f g h
</span></span></code></pre></div><p><strong>Named Tuples</strong>
This enhances the names(field names and a class name) of tuple.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; from collections import namedtuple
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>Name</span> <span class=o>=</span> namedtuple<span class=o>(</span><span class=s1>&#39;Name&#39;</span>, <span class=s1>&#39;first_name last_name&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>junu</span> <span class=o>=</span> Name<span class=o>(</span><span class=s1>&#39;Junu&#39;</span>, <span class=s1>&#39;Park&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>elon</span> <span class=o>=</span> Name<span class=o>(</span><span class=s1>&#39;Elon&#39;</span>, <span class=s1>&#39;Musk&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>prime</span> <span class=o>=</span> Name<span class=o>(</span><span class=s1>&#39;The&#39;</span>, <span class=s1>&#39;Primagen&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; junu
</span></span><span class=line><span class=cl>Name<span class=o>(</span><span class=nv>first_name</span><span class=o>=</span><span class=s1>&#39;Junu&#39;</span>, <span class=nv>last_name</span><span class=o>=</span><span class=s1>&#39;Park&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; elon
</span></span><span class=line><span class=cl>Name<span class=o>(</span><span class=nv>first_name</span><span class=o>=</span><span class=s1>&#39;Elon&#39;</span>, <span class=nv>last_name</span><span class=o>=</span><span class=s1>&#39;Musk&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; prime
</span></span><span class=line><span class=cl>Name<span class=o>(</span><span class=nv>first_name</span><span class=o>=</span><span class=s1>&#39;The&#39;</span>, <span class=nv>last_name</span><span class=o>=</span><span class=s1>&#39;Primagen&#39;</span><span class=o>)</span>
</span></span></code></pre></div><p>As you can see there are two parameters for namedtuple: first one is the class name and second are field names seperated by single space.</p><p>We can use additional methods supported in namedtuples such as,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Name<span class=o>(</span><span class=nv>first_name</span><span class=o>=</span><span class=s1>&#39;The&#39;</span>, <span class=nv>last_name</span><span class=o>=</span><span class=s1>&#39;Primagen&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; prime.last_name
</span></span><span class=line><span class=cl><span class=s1>&#39;Primagen&#39;</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; prime._asdict<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=o>{</span><span class=s1>&#39;first_name&#39;</span>: <span class=s1>&#39;The&#39;</span>, <span class=s1>&#39;last_name&#39;</span>: <span class=s1>&#39;Primagen&#39;</span><span class=o>}</span>
</span></span></code></pre></div><h3 id=slicing>Slicing</h3><p>You can slice not only lists but other sequence types like strings or tuples.</p><p><strong>Why slices and range exclude last item</strong>
because it works well with the zero-based(starting from 0) indexing used in Python.</p><p>More specifically, it&rsquo;s</p><ul><li>easy to see the length of a slice or range when only the stop position is given.</li><li>easy to compute the length of a slice or range when start and stop are given by subtracting them.</li><li>easy to split a sequence in two parts at any index <code>x</code> using the same <code>x</code> without overlapping.</li></ul><p><strong>Using $+$ and $*$ with Sequences</strong></p><p>Multiplying list with integer copies of the same sequence works.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l</span> <span class=o>=</span> <span class=o>[</span>1,2,3<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l2</span> <span class=o>=</span> l * <span class=m>3</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l2  
</span></span><span class=line><span class=cl><span class=o>[</span>1, 2, 3, 1, 2, 3, 1, 2, 3<span class=o>]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l<span class=o>)</span>  
</span></span><span class=line><span class=cl><span class=m>139738068947456</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l2<span class=o>)</span>  
</span></span><span class=line><span class=cl><span class=m>139738067406976</span>
</span></span></code></pre></div><p><strong>Building Lists of Lists</strong></p><p>The problem appears when the elements in the list are mutable items. The most common case is building lists of lists.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>board1</span> <span class=o>=</span> <span class=o>[[</span><span class=s1>&#39;_&#39;</span><span class=o>]</span> * <span class=m>3</span> <span class=k>for</span> i in range<span class=o>(</span>3<span class=o>)]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board1  
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]]</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board1<span class=o>[</span>1<span class=o>][</span>2<span class=o>]</span> <span class=o>=</span> <span class=s1>&#39;x&#39;</span>  
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board1  
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;x&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board1<span class=o>[</span>0<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738042877824</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board1<span class=o>[</span>1<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738043505344</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board1<span class=o>[</span>2<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738043329344</span>
</span></span></code></pre></div><p>board1 works fine, meaning it has different address for each sub arrays.</p><p>but if we multiply list, it just references the same list:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>board2</span> <span class=o>=</span> <span class=o>[[</span><span class=s1>&#39;_&#39;</span><span class=o>]</span> * 3<span class=o>]</span> * <span class=m>3</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board2
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board<span class=o>[</span>1<span class=o>][</span>2<span class=o>]</span> <span class=o>=</span> <span class=s1>&#39;x&#39;</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board2
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span><span class=o>]]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board2<span class=o>[</span>1<span class=o>][</span>2<span class=o>]</span> <span class=o>=</span> <span class=s1>&#39;x&#39;</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; board2
</span></span><span class=line><span class=cl><span class=o>[[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;x&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;x&#39;</span><span class=o>]</span>, <span class=o>[</span><span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;_&#39;</span>, <span class=s1>&#39;x&#39;</span><span class=o>]]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board2<span class=o>[</span>0<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738065760064</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board2<span class=o>[</span>1<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738065760064</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>board2<span class=o>[</span>2<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=m>139738065760064</span>
</span></span></code></pre></div><p>which means it just appends the same row three times.</p><p><strong>Augmented Assignments</strong> (<code>+=</code> and <code>*=</code>)</p><p>augmented assignments are NOT the same as adding or multiplying.
While <code>+</code> internaly uses special function <code>__add__()</code>, <code>+=</code> uses special function <code>__iadd__()</code>.
<strong>Only if <code>__iadd__()</code> is not implemented in the class, it works the same as <code>__add__()</code>.</strong></p><p>so, when does it change?
In mutable sequences (such as lists), <code>__iadd__()</code> will be changed <strong>in place</strong> (using less memory) but in other cases, it will work as <code>__add__()</code> which means <code>a = a + b</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l</span> <span class=o>=</span> <span class=o>[</span>1,2,3<span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738065799168</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>mul_list</span> <span class=o>=</span> l * <span class=m>3</span> <span class=c1># __mul__()</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>mul_list<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738068947456</span> <span class=c1># different address</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l *<span class=o>=</span> <span class=m>3</span> <span class=c1># __imul__()</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738065799168</span> <span class=c1># changed in place</span>
</span></span></code></pre></div><p><strong>A+= Assignment Puzzler</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>t</span> <span class=o>=</span> <span class=o>(</span>1, 2, <span class=o>[</span>30, 40<span class=o>])</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; t<span class=o>[</span>2<span class=o>]</span> +<span class=o>=</span> <span class=o>[</span>50, 60<span class=o>]</span>
</span></span></code></pre></div><p>This is a corner case that I won&rsquo;t go into details since it seems too peripheral.
To explain breifly, this will both make an error but also augment the list into <code>[30, 40, 50, 60]</code>.</p><blockquote><p>• Putting mutable items in tuples is not a good idea.
• <strong>Augmented assignment is not an atomic operation</strong>—we just saw it throwing an exception after doing part of its job.
• Inspecting Python bytecode is not too difficult, and is often helpful to see what is going on under the hood.</p></blockquote><h3 id=sorting>Sorting</h3><p>There are mainly two built-in sorting functions, which is <code>list.sort</code> and <code>sorted</code>.</p><p><code>list.sort</code> does create a copy, but sort the list in place. It returns <code>None</code> to remind it.</p><p>Note: This is a nice pattern to know about Python API conventions: Python usually outputs <code>None</code> to make it clear the function doesn&rsquo;t create a copy but changes the object in place.</p><p><code>sorted</code> creates a new list and returns it. Therefore, takes additional memory. This also means it can take any kinds of iterable object including immutable ones, such as tuples. Note that it always outputs a new <strong>list</strong>.</p><p>Both of the functions take two arguments which are <code>reversed: bool</code> and <code>key: string</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l</span> <span class=o>=</span> <span class=o>[</span><span class=s1>&#39;a&#39;</span>, <span class=s1>&#39;b&#39;</span>, <span class=s1>&#39;c&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>sorted_l</span> <span class=o>=</span> sorted<span class=o>(</span>l<span class=o>)</span> <span class=c1># example of `sorted`</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>l<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738067138496</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; sorted_l
</span></span><span class=line><span class=cl><span class=o>[</span><span class=s1>&#39;a&#39;</span>, <span class=s1>&#39;b&#39;</span>, <span class=s1>&#39;c&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; id<span class=o>(</span>sorted_l<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>139738065799168</span> <span class=c1># another array created</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l.sort<span class=o>()</span> <span class=c1># example of `list.sort`</span>
</span></span></code></pre></div><p>Sorting is very helpful because once the sequence is sorted, each elements can be very efficiently searched.</p><h3 id=managing-ordered-sequence-with-bisect>Managing Ordered Sequence with <code>bisect</code></h3><p>It is good to keep the sorted sequence since sorting is <strong>expensive</strong>.
<code>bisect.bisect</code> and <code>bisect.insort</code> helps a much efficient way to search and insert than <code>list</code> functions.</p><p><a href=https://en.wikipedia.org/wiki/Binary_search>Binary Search Algorithm</a> is provided via <code>bisect</code> module in Python standard library.</p><p>Bisect is an efficient way to search and insert elements into a sequence <strong>while keeping the order</strong> in an ordered sequence.</p><p><code>bisect()</code> returns the location where the element should be inserted in order to maintain the order while <code>insort()</code> finds the location and inserts the element.</p><p>a quick minimal example would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; import bisect
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>l</span> <span class=o>=</span> <span class=o>[</span>1, 2, 3, 4, 5<span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l
</span></span><span class=line><span class=cl><span class=o>[</span>1, 2, 3, 4, 5<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># bisect only tells you the location</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.bisect<span class=o>(</span>l, 6<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>5</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.bisect<span class=o>(</span>l, 3<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>3</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.bisect<span class=o>(</span>l, 4<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>4</span>
</span></span><span class=line><span class=cl><span class=c1># insort actually inserts the array</span>
</span></span><span class=line><span class=cl><span class=c1># this is an in-place exchange so only one block of</span>
</span></span><span class=line><span class=cl><span class=c1># memory will be added</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.insort<span class=o>(</span>l, 3<span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; l
</span></span><span class=line><span class=cl><span class=o>[</span>1, 2, 3, 3, 4, 5<span class=o>]</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; bisect.bisect<span class=o>(</span>l, 3<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>4</span>
</span></span></code></pre></div><h3 id=when-a-list-is-not-the-answer>When a List is Not the Answer</h3><p><strong>Arrays</strong></p><p>When creating an array,</p><ol><li>you provide a typecode</li><li>a letter to determine the underlying C type used to store each item in the array.</li></ol><p>For example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; from array import array
</span></span><span class=line><span class=cl>&gt;&gt;&gt; from random import random
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>floats</span> <span class=o>=</span> array <span class=o>(</span><span class=s1>&#39;d&#39;</span>, <span class=o>(</span>random<span class=o>()</span> <span class=k>for</span> i in range<span class=o>(</span>2**10<span class=o>)))</span>
</span></span></code></pre></div><p>&lsquo;b&rsquo;: signed char
&rsquo;d&rsquo;: double</p><p>whatever you assign to, the array will interpret as the type you assigned to it.</p><p>Fast loading and saving are available via <code>.frombytes</code> and <code>.tofile</code>
Binary file can be 60x faster than reading numbers in text file.</p><p><strong>Memory Views</strong></p><blockquote><p>A memoryview is essentially a generalized NumPy array structure in Python itself (without the math). It allows you to share memory between data-structures (things like PIL images, SQLlite databases, NumPy arrays, etc.) without first copying.</p></blockquote><p><strong>NumPy and SciPy</strong></p><p><strong>Deque</strong></p><p><code>deque</code> (not <em>dequeue</em>) stands for &lsquo;double-ended queue&rsquo;.</p><p>Removing items from the middle of a <code>deque</code> is not as fast. It&rsquo;s optimized for appending and popping from the end. Used in LIFO queue.</p><p>deque internally is implemented as a doubly linked list of fixed-size blocks. Therefore traversing to the middle would be more ineffecient than accesing the ends.</p><blockquote><p>Hash tables are the engines behind Python&rsquo;s high-performance dicts.</p></blockquote><p>All mapping types in the std library use the basic dict in their implementation, which means all keys(while values are not required) must be <em>hashable</em>.</p><p>This means, in order to understand how dictionary or set in Python works under the hood, we should understand about hash first.</p><p><strong>About <em>hash</em></strong></p><p><em>What is hash and what does it mean to be hashable?</em></p><p>A <em>hash</em> is a numeric value that Python calculates for a hashable object.
It&rsquo;s like a unique, short fingerprint for that specific object.
<em>hashable</em> means it can be hashed.</p><p><em>Why does hash make searching faster?</em></p><p>When we feed in a hashable key-value pair, Python will take the (hashable) key and feed it to a <em>hash function</em>. This function will quickly compute an integer number called <em>hash value</em>.</p><p>This hash value is then mathematically mapped to a specific index (or bucket) within an internal array that the dictionary uses to store its items.</p><p>This makes <strong>direct memory access available</strong>. This means, hash table design allows Python to use key to <strong>go directly</strong> to the calculated index in its internal value, without needing to scan other parts of the memory.</p><p><em>What are the hashable types?</em></p><ul><li>atomic immutable types (such as <code>str</code>)</li><li><code>frozen set</code></li><li><code>tuple</code> is hashable only if all its items are hashable<ul><li>If we look at the example below, unlike <code>tf</code>, <code>tl</code> will produce an error since there is an unhashable list inside the tuples.</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>tl</span> <span class=o>=</span> <span class=o>(</span>1,2,<span class=o>[</span>30,40<span class=o>])</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; hash<span class=o>(</span>tl<span class=o>)</span>
</span></span><span class=line><span class=cl>Traceback <span class=o>(</span>most recent call last<span class=o>)</span>: 
</span></span><span class=line><span class=cl>File <span class=s2>&#34;&lt;stdin&gt;&#34;</span>, line 1, in &lt;module&gt;
</span></span><span class=line><span class=cl>TypeError: unhashable type: <span class=s1>&#39;list&#39;</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt;
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>tf</span> <span class=o>=</span> <span class=o>(</span>1,2,frozenset<span class=o>([</span>30,40<span class=o>]))</span> 
</span></span><span class=line><span class=cl>&gt;&gt;&gt; hash<span class=o>(</span>tf<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>5149391500123939311</span>
</span></span></code></pre></div><p>There are multiple ways to create dicts.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>a</span> <span class=o>=</span> dict<span class=o>(</span><span class=nv>one</span><span class=o>=</span>1, <span class=nv>two</span><span class=o>=</span>2, <span class=nv>three</span><span class=o>=</span>3<span class=o>)</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>b</span> <span class=o>=</span> <span class=o>{</span><span class=s1>&#39;one&#39;</span>: 1, <span class=s1>&#39;two&#39;</span>: 2, <span class=s1>&#39;three&#39;</span>: 3<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1># combine multiple iterable objects element-wise</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>c</span> <span class=o>=</span> dict<span class=o>(</span>zip<span class=o>([</span><span class=s1>&#39;one&#39;</span>, <span class=s1>&#39;two&#39;</span>, <span class=s1>&#39;three&#39;</span><span class=o>]</span>, <span class=o>[</span>1,2,3<span class=o>]))</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>d</span> <span class=o>=</span> dict<span class=o>([(</span><span class=s1>&#39;two&#39;</span>,2<span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;one&#39;</span>, 1<span class=o>)</span>, <span class=o>(</span><span class=s1>&#39;three&#39;</span>, 3<span class=o>)])</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>e</span> <span class=o>=</span> dict<span class=o>({</span><span class=s1>&#39;three&#39;</span>: 3, <span class=s1>&#39;one&#39;</span>: 1, <span class=s1>&#39;two&#39;</span>: 2<span class=o>})</span>
</span></span><span class=line><span class=cl>&gt;&gt;&gt; <span class=nv>a</span> <span class=o>==</span> <span class=nv>b</span> <span class=o>==</span> <span class=nv>c</span> <span class=o>==</span> <span class=nv>d</span> <span class=o>==</span> e  
</span></span><span class=line><span class=cl>True
</span></span></code></pre></div><p><strong>Handling Missing Keys with <code>setdefault</code></strong></p><p>When looking up table and checking if it&rsquo;s key is missing, it&rsquo;s more efficient to use <code>setdefault</code> than <code>d.get(k, default)</code>.</p></div><nav class=post-nav><div class=nav-prev><a href=https://junuxyz.github.io/posts/lab01-adding-vector/ class=nav-link><span class=nav-label>← Previous</span>
<span class=nav-title>Lab01: Adding Vector</span></a></div></nav></article></div></main><footer class=footer><div class=footer-content><p>&copy; 2025 junuxyz. Built with <a href=https://gohugo.io/>Hugo</a>.</p></div></footer><script src=/js/theme.js></script></body></html>